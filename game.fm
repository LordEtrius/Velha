import Base#
import Matrix

// Data Structures
// --------------

// A value that a cell in the Matrix can have
T Value
| e
| x
| o

// Identify Row and Col positions in a Matrix 3x3
T Row_Col
| r0
| r1
| r2
  
GameMap : Type
  Matrix(Value)

T GameState
| game_state(
  map: GameMap,
  is_ative: Bool
  )

Log : Type
  List(GameMap)

// Describes the winning triple position
TripleMatch : Type
  List(Number)

// show_map(gm: GameMap) : String
//   case gm
//   | nil  => []
//   | cons => case gm.head 
//     | e => cons(_ '?', show_map(gm.tail))
//     | x => cons(_ 'x', show_map(gm.tail))
//     | o => cons(_ 'o', show_map(gm.tail))

// Auxiliary
// ---------

show_formatted_map(size: Nat, str: String) : String
  case size
  + show_formatted_map : Nat -> String -> String // do I need this?
  | zero => nil(_)
  | succ => 
    case str
    | nil  => nil(_)
    | cons => 
      let num = nat_to_number(size)
      if (num .%. 3) .==. 0 then 
        // let new_line = concat(_ str.head, 12) // head is a single element
        cons(_ str.head, show_formatted_map(size.pred, str.tail))
      else 
        cons(_ str.head, show_formatted_map(size.pred, str.tail))
  : String

// Check if two Values are equal
is_value_equal(value: Value, match: Value) : Bool
  case value
  | e => 
    case match
    | e => true
    | x => false
    | o => false
  | x => 
    case match
    | e => false
    | x => true
    | o => false
  | o =>
    case match
    | e => false
    | x => false
    | o => true

// Transforms Nat to Number
nat_to_number(nat: Nat) : Number
  case nat
  | zero => 0
  | succ => 1 .+. (nat_to_number(nat.pred))

// Transforms a Matrix in String of Values
show_matrix(m: Matrix(Value)) : String
  case m
  | m_nil  => []
  | m_cons => 
    case m.head as aux
    | e => cons(_ '?', show_matrix(m.tail))
    | x => cons(_ 'x', show_matrix(m.tail))
    | o => cons(_ 'o', show_matrix(m.tail))

equal_x(e : Value) : Bool
  case e 
  | e => false 
  | x => true
  | o => false
  : Bool

equal_o(e : Value) : Bool
  case e 
  | e => false 
  | x => false
  | o => true
  : Bool

// Transforms a Row_Col to Number
row_col_number(rc: Row_Col) : Number
  case rc
  | r0 => 0
  | r1 => 1
  | r2 => 2

// Game states
// -----------
empty_game_map : GameMap
  let l = 
  [e, e, e,
   e, e, e,
   e, e, e]
  list_to_matrix(_ l)

init_game : GameState
  game_state(empty_game_map, true)


// Actions
// -------
// If possible, adds a new Value on empty cell
add_value(value: Value, idx: Nat, map: GameMap) : GameMap
  let index_value = get_value_at(map, idx)
  let index_is_empty = is_value_equal(e, index_value)
  case index_is_empty 
  | true  => set_value_at(value, idx, map)
  | false => map

// Mark value ('x' or 'o') on a cell
set_value_at(val: Value, idx: Nat, mx: GameMap) : GameMap
  case idx
  + mx: GameMap
  | zero => 
    case mx
    | m_nil  => m_nil(_)
    | m_cons => m_cons(_ mx.row, mx.col, val, mx.tail)
  | succ =>
    case mx
    | m_nil => m_nil(_)
    | m_cons => m_cons(_ mx.row, mx.col, mx.head, set_value_at(val, idx.pred, mx.tail))


get_value_at(mx: GameMap, idx: Nat) : Value
  case mx
  | m_nil  => e
  | m_cons => case idx
    | zero => mx.head
    | succ => get_value_at(mx.tail, idx.pred)
  : Value


// Check if the values are all equal to value 'x'
// values: a Matrix of 3 elements
match_x(values: Matrix(Value)) : Maybe(Matrix(Value))
  let filter_x = filter_mx(_ equal_x, values) // list of "x" elements
  let len_filtered = length_mx(_ filter_x)
  if nat_to_number(len_filtered) .==. 3 then
    some(_ values)
  else 
    none(_)

// Check if the values are all equal to value 'o'
// values: a Matrix of 3 elements
match_o(values: Matrix(Value)) : Maybe(Matrix(Value))
  let filter_o = filter_mx(_ equal_o, values) // list of "o" elements
  let len_filtered = length_mx(_ filter_o)
  if nat_to_number(len_filtered) .==. 3 then
    some(_ values)
  else 
    none(_)

// values: a Matrix of 3 elements
match_x_or_o(values: Matrix(Value)) : Maybe(Matrix(Value))
  let match_x = match_x(values)
  case match_x
  | none => match_o(values) // check if match 'o'
  | some => some(_ match_x.value)

// Returns a Matrix 1x3 that stands for a given row in a Matrix 3x3
get_row(map: GameMap, row: Row_Col) : Matrix(Value)
  list_to_matrix(_ 
    case row
    | r0 => [get_value_at(map, 0n), get_value_at(map, 1n), get_value_at(map, 2n)]
    | r1 => [get_value_at(map, 3n), get_value_at(map, 4n), get_value_at(map, 5n)]
    | r2 => [get_value_at(map, 6n), get_value_at(map, 7n), get_value_at(map, 8n)]
  )

// Check horizontals
// -----------------
// map: Matrix(Value) 3x3
check_rows(map: Matrix(Value)) : Maybe(Matrix(Value))
  let row_0 = match_x_or_o(get_row(map, r0))
  case row_0
  | none => 
    let row_1 = match_x_or_o(get_row(map, r1))
    case row_1
    | none => match_x_or_o(get_row(map, r2)) // returns the result of row 2
    | some => some(_ row_1.value) // winner on row 1
  | some => some(_ row_0.value) // winner on row 0
  



// ------------------

// Add a new log on map event
add_event_log(entry: GameMap, log: Log) : Log
  cons(_ entry, log)
  
// 1. Game starts with an empty map
// 1st player make his move
// Game adds a new state if the move is valid
// 2nd player make his move
  




