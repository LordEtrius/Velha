import Base#
import Matrix

// Data Structures
// --------------

T Value
| e
| x
| o

GameMap : Type
  Matrix(Value)

T GameState
| game_state(
  map: GameMap,
  is_ative: Bool
  )

Log : Type
  List(GameMap)

// Describes the winning triple position
TripleMatch : Type
  List(Number)

// show_map(gm: GameMap) : String
//   case gm
//   | nil  => []
//   | cons => case gm.head 
//     | e => cons(_ '?', show_map(gm.tail))
//     | x => cons(_ 'x', show_map(gm.tail))
//     | o => cons(_ 'o', show_map(gm.tail))

// Auxiliary
// ---------

show_formatted_map(size: Nat, str: String) : String
  case size
  + show_formatted_map : Nat -> String -> String // do I need this?
  | zero => nil(_)
  | succ => 
    case str
    | nil  => nil(_)
    | cons => 
      let num = nat_to_number(size)
      if (num .%. 3) .==. 0 then 
        // let new_line = concat(_ str.head, 12) // head is a single element
        cons(_ str.head, show_formatted_map(size.pred, str.tail))
      else 
        cons(_ str.head, show_formatted_map(size.pred, str.tail))
  : String

// get_value_at(A; index: Nat, xs: List(A), default: A) : A
//   let value_at = at(_ index, xs)
//   with_default(_ default, value_at)

is_value_equal(value: Value, match: Value) : Bool
  case value
  | e => 
    case match
    | e => true
    | x => false
    | o => false
  | x => 
    case match
    | e => false
    | x => true
    | o => false
  | o =>
    case match
    | e => false
    | x => false
    | o => true
  
nat_to_number(nat: Nat) : Number
  case nat
  | zero => 0
  | succ => 1 .+. (nat_to_number(nat.pred))

show_matrix(m: Matrix(Value)) : String
  case m
  | m_nil  => []
  | m_cons => 
    case m.head as aux
    | e => cons(_ '?', show_matrix(m.tail))
    | x => cons(_ 'x', show_matrix(m.tail))
    | o => cons(_ 'o', show_matrix(m.tail))

equal_x(e : Value) : Bool
  case e 
  | e => false 
  | x => true
  | o => false
  : Bool

equal_o(e : Value) : Bool
  case e 
  | e => false 
  | x => true
  | o => false
  : Bool

// Game states
// -----------
empty_game_map : GameMap
  let l = 
  [e, e, e,
   e, e, e,
   e, e, e]
  list_to_matrix(_ l)

init_game : GameState
  game_state(empty_game_map, true)


// Actions
// -------
// If possible, adds a new Value on empty cell
add_value(value: Value, idx: Nat, map: GameMap) : GameMap
  let index_value = get_value_at(map, idx)
  let index_is_empty = is_value_equal(e, index_value)
  case index_is_empty 
  | true  => set_value_at(value, idx, map)
  | false => map

// Mark value ('x' or 'o') on a cell
set_value_at(val: Value, idx: Nat, mx: GameMap) : GameMap
  case idx
  + mx: GameMap
  | zero => 
    case mx
    | m_nil  => m_nil(_)
    | m_cons => m_cons(_ mx.row, mx.col, val, mx.tail)
  | succ =>
    case mx
    | m_nil => m_nil(_)
    | m_cons => m_cons(_ mx.row, mx.col, mx.head, set_value_at(val, idx.pred, mx.tail))


get_value_at(mx: GameMap, idx: Nat) : Value
  case mx
  | m_nil  => e
  | m_cons => case idx
    | zero => mx.head
    | succ => get_value_at(mx.tail, idx.pred)
  : Value


// Check if the values are all equal to value 'x'
// values: a Matrix of 3 elements
match_x(values: Matrix(Value)) : Maybe(Matrix(Value))
  let filter_x = filter_mx(_ equal_x, values) // list of "x" elements
  let len_filtered = length_mx(_ filter_x)
  if nat_to_number(len_filtered) .==. 3 then
    some(_ values)
  else 
    none(_)

// Check if the values are all equal to value 'o'
// values: a Matrix of 3 elements
match_o(values: Matrix(Value)) : Maybe(Matrix(Value))
  let filter_o = filter_mx(_ equal_o, values) // list of "o" elements
  let len_filtered = length_mx(_ filter_o)
  if nat_to_number(len_filtered) .==. 3 then
    some(_ values)
  else 
    none(_)

// Check horizontals
// check_h_0(mx: Matrix(Value)) : Maybe(Matrix(Value))


// ------------------

// Add a new log on map event
add_event_log(entry: GameMap, log: Log) : Log
  cons(_ entry, log)
  
// 1. Game starts with an empty map
// 1st player make his move
// Game adds a new state if the move is valid
// 2nd player make his move
  




