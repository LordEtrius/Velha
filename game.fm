import Base#
import Matrix

// Data Structures
// --------------

T Value
| e
| x
| o

GameMap : Type
  List(Value)

T GameState
| game_state(
  map: GameMap,
  is_ative: Bool
  )

Log : Type
  List(GameMap)

// Describes the winning triple position
TripleMatch : Type
  List(Number)

// show_map(gm: GameMap) : String
//   case gm
//   | nil  => []
//   | cons => case gm.head 
//     | e => cons(_ '?', show_map(gm.tail))
//     | x => cons(_ 'x', show_map(gm.tail))
//     | o => cons(_ 'o', show_map(gm.tail))

// Auxiliary
// ---------

show_formatted_map(size: Nat, str: String) : String
  case size
  + show_formatted_map : Nat -> String -> String // do I need this?
  | zero => nil(_)
  | succ => 
    case str
    | nil  => nil(_)
    | cons => 
      let num = nat_to_number(size)
      if (num .%. 3) .==. 0 then 
        // let new_line = concat(_ str.head, 12) // head is a single element
        cons(_ str.head, show_formatted_map(size.pred, str.tail))
      else 
        cons(_ str.head, show_formatted_map(size.pred, str.tail))
  : String

get_value_at(A; index: Nat, xs: List(A), default: A) : A
  let value_at = at(_ index, xs)
  with_default(_ default, value_at)

is_value_equal(value: Value, match: Value) : Bool
  case value
  | e => 
    case match
    | e => true
    | x => false
    | o => false
  | x => 
    case match
    | e => false
    | x => true
    | o => false
  | o =>
    case match
    | e => false
    | x => false
    | o => true
  
nat_to_number(nat: Nat) : Number
  case nat
  | zero => 0
  | succ => 1 .+. (nat_to_number(nat.pred))

show_matrix(m: Matrix(Value)) : String
  case m
  | m_nil  => []
  | m_cons => 
    case m.head as aux
    | e => cons(_ '?', show_matrix(m.tail))
    | x => cons(_ 'x', show_matrix(m.tail))
    | o => cons(_ 'o', show_matrix(m.tail))

// Output "oox"
test.diagonalLR
  let a = 
  [o, e, e,
   e, o, e,
   e, e, x]
  show_matrix(diagonalLR(_ list_to_matrix(_ a), 9n))

// Output "xo?"
test.diagonalRL
  let a = 
  [o, e, x,
   e, o, e,
   e, e, o]
  show_matrix(diagonalRL(_ list_to_matrix(_ a), 9n))

equal_x(e : Value) : Bool
  case e 
  | e => false 
  | x => true
  | o => false
  : Bool

equal_o(e : Value) : Bool
  case e 
  | e => false 
  | x => true
  | o => false
  : Bool

// Game states
// -----------
empty_game_map : GameMap
  [e, e, e,
   e, e, e,
   e, e, e]

init_game : GameState
  game_state(empty_game_map, true)


// Actions
// -------
// If possible, adds a new Value on empty cell
add_value(value: Value, index: Nat, map: GameMap) : GameMap
  let index_value = get_value_at(_ index, map, e)
  let index_is_empty = is_value_equal(e, index_value)
  case index_is_empty 
  | true  => set_value_at(_ value, index, map)
  | false => map

// Mark value ('x' or 'o') on a cell
set_value_at(A; val: A, idx: Nat, xs: List(A)) : List(A)
  case idx
  | zero => 
    case xs
    | nil  => nil(_)
    | cons => cons(_ val , xs.tail)
  | succ =>
    case xs
    | nil => nil(_)
    | cons => cons(_ xs.head, set_value_at(_ val, idx.pred, xs.tail))

// mx: a Matrix with 9 elements
// match_diagonal(A; mx: Matrix(A)): Match_Triple
//   let match_diagonal_lr_x = match_x(mx)


T Match_Triple
| no_match
| match_diagonal_lr(mx: Matrix(Value))
| match_diagonal_rl(mx: Matrix(Value))

test_match_triple : Matrix(Value)
  let l = [x, x, e]
  let m = list_to_matrix(_ l)
  let res = match_x(m)
  case res
  | none => m_nil(_)
  | some => res.value
  // nat_to_number(match_x(m))

// Check if the values are all equal to value 'x'
// values: a Matrix of 3 elements
match_x(values: Matrix(Value)) : Maybe(Matrix(Value))
  let filter_x = filter_mx(_ equal_x, values) // list of "x" elements
  let len_filtered = length_mx(_ filter_x)
  if nat_to_number(len_filtered) .==. 3 then
    some(_ values)
  else 
    none(_)

// Check if the values are all equal to value 'o'
// values: a Matrix of 3 elements
match_o(values: Matrix(Value)) : Maybe(Matrix(Value))
  let filter_o = filter_mx(_ equal_o, values) // list of "o" elements
  let len_filtered = length_mx(_ filter_o)
  if nat_to_number(len_filtered) .==. 3 then
    some(_ values)
  else 
    none(_)

// ------------------

// Add a new log on map event
add_event_log(entry: GameMap, log: Log) : Log
  cons(_ entry, log)
  
// 1. Game starts with an empty map
// 1st player make his move
// Game adds a new state if the move is valid
// 2nd player make his move

main
  let game_map = [e, e, e,
   e, e, e,
   e, e, e]

  let new_map = set_value_at(_ x, 1n, a)
  let move_1 = add_value(x, 2n, a)
  let move_2 = add_value(o, 0n, move_1)
  let stringfied = show_map(move_2)
  // stringfied
  show_formatted_map(length(stringfied), stringfied)
  // let a = [0, 1, 2, 3]
  // set_value_at(_ 9, 5n, a)
  




